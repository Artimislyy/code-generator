基于 Spring Boot + Picocli + 对象存储的代码生成器共享平台。 开发者可以在线制作发布代码生成器，用户可以搜索、下载、在线使用生成器(比如生成项目模板)，管理员可以集中管理所有用户和生成器。
由于项目复杂，拆分为3个阶段依次实现:本地代码生成器、生成器制作工具、生成器 web 平台。
<br><br>
# 1)第一阶段，本地代码生成器
制作本地代码生成器 ，基于命令行的脚手架 ，能够根据用户的交互式输入快速生成特定代码。 涉及模板引擎、命令行开发等技术。
## 业务流程
1)准备用于制作代码生成器的原始代码(比如 Java ACM 模板项目)，用于后续生成
<br>2)开发者基于原始代码，设置参数、编写动态模板
<br>3)制作可交互的命令行工具，支持用户输入参数，得到代码生成器jar 包
<br>4)使用者得到代码生成器jar 包，执行程序并输入参数，从而生成完整代码
<br>流程图如下：
<br>

![img_1.png](img_1.png)
## 主要工作
本地代码生成器:能接受用户传入的参数，动态生成代码文件。
<br>1)采用**动静分离**策略，基于freeMarker实现动态代码生成，使用Hutool fileUti递归复制静态文件，提高了整体生成性能。
<br>2)基于Picocli框架，将代码生成功能封装为命令行程序，用户可以交互式地输入生成代码所需的参数，并且封装程序为Shell脚本，进一步简化调用。
<br>3)基于**命令模式**实现代码生成、列举文件、查看配置等多个子命令，每个命令互不影响，使系统更易于扩展。

# 2）第二阶段，代码生成器制作工具
制作本地代码生成器的**制作工具**，能够快速将一个项目制作为可以动态定制部分内容的代码生成器。 并且以一个 Spring Boot初始化项目模板为例。
## 业务流程
1)准备用于制作代码生成器的原始代码(比如 Spring Boot 项目模板)，用于后续生成
<br>2)开发者基于原始代码，使用代码生成器**制作工具**，来快速设置参数、生成动态模板
<br>3)使用代码生成器制作工具，动态生成代码生成器 jar 包
<br>4)使用者得到代码生成器 jar 包，执行程序并输入参数，从而生成完整代码相比第一阶段的业务流程，本阶段完成后，可以直接使用代码生成器制作工具来快速将固定的项目代码改造为可定制生成的动态模板，并自动生成命令行工具iar 包。
<br>流程图如下：
<br>
![img.png](img.png)
## 主要工作
生成器制作工具:开发者只需提供模板文件和制作配置，就能快速制作可执行的代码生成器。
<br>1.通过**元信息设计**来规范代码生成器的信息(比如要生成的文件和传入数据)，可以通过 JSON 配置修改元信息，驱动生成器的制作。
<br>2.基于**双检锁单例模式**实现了元信息读取类，仅执行一次将元信息 JSON 转为对象的流程，防止重复实例化。
<br>3.使用Java Process类动态调用Maven命令，将生成的代码制作为可执行Jar包，并通过 BufferedReader 获取命令执行结果。
<br>4.在元信息的文件配置中，使用相对路径寻址，使得制作工具具备可移植性，可复制到其他机器运行。
<br>5.由于元信息配置较为复杂，编写元信息校验类，集中校验元信息并填充默认值，提高了程序的健壮性。
<br>6.由于元信息的校验逻辑复杂、代码分支多，使用MetricsReloaded插件检测圈复杂度，并通过卫语句、封装方法、语法糖等方式将平均**圈复杂度由 62 降低到 7.5** 。
<br>7.由于生成器制作流程较多、代码复杂，使用**模板方法模式**，将主流程定义为抽象模板，通过子类重写各个具体的生成环节，使系统更易于维护扩展。

## 2.1 模板制作工具
模板制作工具:能够快速对静态文件“挖坑"，生成 FTL 模板和元信息配置，提高生成器制作效率。
<br>1.采用 **工作空间** 机制，制作模板时通过 **雪花算法** 生成唯一目录，保证不污染原项目文件、每次制作互不影响
<br>2.设计文件过滤机制，支持通过配置的方式从目录中筛选指定的文件进行制作，比如按正则匹配文件内容。
<br>3.有状态化:通过给每次模板制作生成唯一id，实现分步制作、追加配置的能力，并通过 Stream API 实现配置的去重。

# 3）第三阶段，在线代码生成器平台
## 业务流程
1)获取用于制作代码生成器的原始代码(手动准备或者远程拉取代码)
<br>2)开发者基于原始代码，使用**在线代码生成器制作工具**，来快速制作代码生成器
<br>3)开发者发布代码生成器至平台
<br>4)使用者在平台上搜索代码生成器，支持在线使用或者下载离线jar包(甚至还可以支持接口调用)
<br>流程图如下：
<br>
![img_2.png](img_2.png)

## 主要工作
web 平台:提供生成器在线制作、发布、使用、下载能力。
<br>1.库表设计:由于生成器的文件配置复杂，使用 JSON 对象代替多列存储，使字段更利于扩展
<br>2.基于自己二次开发的 Spring Boot 初始化模板+ MyBatisX插件，快速生成用户、生成器的增删改查代码。
<br>3.自主封装可复用的 COS 对象存储操作类，可通过 Config 类读取配置并生成实例，实现了生成器文件的上传下载。
<br>4.由于下载生成器较慢，通过服务端缓存已下载文件，减少从对象存储拉取文件的耗时。对于大文件，实测下载时长可 缩短 100 倍。
<br>5.为减少查询生成器接口的响应时长，优化 SQL，仅查询前端必要的数据，实测响应时长减少了 1/3。
<br>6.为优化查询生成器接口的性能，使用 JMeter 配置线程组进行压测，通过响应断言和聚合报告获取压测结果。
<br>7.为优化查询生成器接口的性能，基于 Redis +Caffeine 实现多级缓存，兼具持久化和高性能，并编写了通用的多级缓存操作类。相比直查 DB，响应时长缩短了 80%、qps 提升了 3倍。
<br>8.为进一步优化性能，对于缓存操作采用 JDK 默认序列化替代JSON 序列化，减少 CPU 计算，实测 qps 提升了5倍。
<br>9.请求层性能优化:通过调整 tomcat最大线程数配置，将 qps 提升了1倍;并尝试通过 Vert.x反应式编程框架替代 tomcat 接受请求。
<br>10.为防止文件存储超限，设计了每日定时的文件清理机制，并通过 XXL-JOB 解决了分布式任务冲突，节约了 10% 的存储空间。
<br>11.针对生成器发布后访问频率持续降低的情况，设计了 **数据沉降机制** ，将发布 30 天后的生成器文件转储到更便宜的低频存储，节约 34% 的成本。
<br>12.为保证存储安全，对 COS 配置了防盗链;并基于 **最小权限原则** ，先将存储桶访问权限设置为私有读写，再配置 Policy 白名单允许访问生成器图片。
<br>13.使用宝塔 linux，通过运行 Jar 包快速部署后端;并通过 Nginx 反向代理，将请求转发到后端，防止跨域。

